<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>μTask</title>
  <style>
    * { margin: 0; padding: 0; }

    html {
      font-family: Arial;
      font-size: 10pt;
      height: 100%;
    }

    p {
      margin-bottom: .5em;
    }

    .tool-overlay {
      position: fixed;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      font-size: 0;
      text-align: right;
      pointer-events: none;
      z-index: 10;
    }

    .tool-overlay:before {
      content: "";
      height: 100%;
      display: inline-block;
      vertical-align: middle;
    }

    .tools {
      height: 90%;
      display: inline-block;
      vertical-align: middle;
      pointer-events: auto;
      -moz-transform: translate(-moz-calc(100% - 30px), 0);
      -webkit-transform: translate(-webkit-calc(100% - 30px), 0);
      -moz-transition: all .4s ease;
      -webkit-transition: all .4s ease;
      border: 2px solid gray;
      border-right: none;
      font-size: 10pt;
      background-color: white;
    }

    .tools:hover {
      -moz-transform: translate(0, 0);
      -webkit-transform: translate(0, 0);
      opacity: .95;
    }

     #toolbar:before {
      content: "";
      height: 100%;
      display: inline-block;
      vertical-align: middle;
     }

    #toolbar {
      width: 30px;
      height: 100%;
      display: inline-block;
      vertical-align: middle;
      text-align: center;
    }

    #editpad {
      text-align: left;
      font-family: monospace;
      overflow: auto;
      width: 80ex;
      height: 100%;
      display: inline-block;
      vertical-align: middle;

      -moz-box-sizing: border-box;
      box-sizing: border-box;

      border: none;
      padding: .5em;
    }

  #editpad.modified {
    box-shadow: inset 0 0 2px 2px #33CDC7;
  }

    #editpad:focus {
      border: none;
    }

    #board {
      -moz-box-sizing: border-box;
      box-sizing: border-box;
      display: -webkit-flex;
      display: -moz-box;
      display: box;
      width: 100%;
    }

    #board .group {
      display: -webkit-flex;
      display: -moz-box;
      display: box;
      -webkit-box-pack: justify;
      -webkit-box-align: stretch;
      -webkit-box-flex: 1;
      -moz-box-pack: justify;
      -moz-box-align: stretch;
      -moz-box-flex: 1;
      box-pack: justify;
      box-align: stretch;
      box-flex: 1;
    }

    #board .group.vertical {
      -webkit-flex-direction: column;
      -moz-box-orient: block-axis;
      box-orient: block-axis;
    }

    #board .group.horizontal {
      -webkit-flex-direction: row;
      -moz-box-orient: inline-axis;
      box-orient: inline-axis;
    }

    #board .group * {
      -webkit-box-flex: 1;
      -moz-box-flex: 1;
      box-flex: 1;
    }

    #board .state {
      border: 1px dashed #EEE;
      padding: 1em;
    }

    .task {
      position: relative;
      min-width: 10em;
      max-width: 15em;
      margin: 1em;
      padding: .5em;
      border: 1px solid #FFD440;
      border-radius: 5px;
      background-color: #FFE073;
      box-shadow: 1px 1px 2px #444;
    }

    .task h1 {
      margin-top: .5em;
      margin-bottom: .25em;
      font-size: large;
    }

    .task progress {
      width: 100%;
    }

    .task:hover aside {
      -moz-transform: translate(0,0);
      -webkit-transform: translate(0,0);
      opacity: 1.0;
    }

    .task aside {
      position: absolute;
      top: -moz-calc(100% + 8px);
      top: -webkit-calc(100% + 8px);
      left: 0;
      right: 0;
      background: #444;
      color: #FFF;
      padding: .5em;
      border-radius: 0 0 5px 5px;
      box-shadow: 1px 1px 2px #444;
      z-index: 1;

      -moz-transform: translate(0,-50%);
      -webkit-transform: translate(0,-50%);
      opacity: 0.0;

      -moz-transition: all ease 0.25s;
      -webkit-transition: all ease 0.25s;
    }

    .task aside:before {
      content: '';
      width: 0;
      height: 0;
      border-left: 12px solid transparent;
      border-right: 12px solid transparent;
      border-bottom: 12px solid #444;

      position: absolute;
      top: -11px;
      left: -moz-calc(50% - 12px);
      left: -webkit-calc(50% - 12px);
    }

    .task aside progress {
      -webkit-appearance: none;
      height: 4px;
      position: relative;
      top: -4px;
    }

    .task aside dl dt {
      float: left;
      margin-right: 1ex;
    }

    .task aside dl dt:after {
      content: ':';
    }

    .task aside dl dd {
      font-weight: bold;
    }

    .task .id {
      color: #FFE073;
      text-shadow:1px 1px #222;
    }

    .task .category {
      border: #FFF 1px solid;
      border-radius: 5px;
      color: #FFF;
      padding: .25em;
      margin-left: .5em;
    }

    .state .task {
      display: inline-block;
    }

  </style>
</head>
<body>
  <section class="tool-overlay">
    <section class="tools">
      <section id="toolbar">
        ◀
      </section>
      <textarea contenteditable id="editpad">To do:
  Task 13: Add task icons
  Task 15: Default named colors
  Task 16: Style progress bars

Doing:
  Task 14: Syntax for priorities
  Task 9: Syntax for tags
  Task 10: Syntax for people assignements

Done:
  Task 1: Compatibilize layout
  Task 2: Flow integrity
  Task 6: Definition parser
  Task 7: Classification parser
  Task 8: Syntax for categories
  Task 11: Syntax for completion
  Task 12: Syntax for due dates

Unscheduled:
  Task 3: Dynamic kanban
  Task 4: Dynamic flows
  Task 5: Interactive board

--

Features:

  Task 1: Compatibilize layout
  Make the layout compatible with Chrome

  Task 2: Flow integrity
  Ensure you cannot add the same task to more than one step

  Task 5: Interactive board
  Allow the user to use the board view to move tasks from one step to another

  Task 13: Add task icons
  Icons to indicate completion and due date

  Task 15: Default named colors
  Add some named colors instead of #rgb colors

  Task 16: Style progress bars
  Add CSS to style progress bar for completion

Kanban & Flow themes (#FF8C34):

  Task 3: Dynamic kanban
  Make kanban layout dynamic and based on themes

  Task 4: Dynamic flows
  Make flow transitions dynamic and based on themes

Parsers (#F71BBA):

  Task 6: Definition parser
  Implement the parser for definitions

  Task 7: Classification parser
  Implement the parser for classification of tasks

Syntax (#30E266):

  Task 8: Syntax for categories
  Think about some syntax to present categories

  Task 9: Syntax for tags
  Think about some syntax to tag tasks
  >> 1h/4h (01/2014)

  Task 10: Syntax for people assignements
  Think about some syntax to indicate people assignements
  >> 1h/4h (01/2014)

  Task 11: Syntax for completion
  Think about some syntax to indicate completion

  Task 12: Syntax for due dates
  Think about some syntax to indicate a deadline

  Task 14: Syntax for priorities
  Think about a syntax for priorities
  >> 1h/4h (01/2014)</textarea>
    </section>
  </section>
  <section id="board">
    <div class="group vertical">
      <div class="group horizontal">
        <section id="to_do" class="state">
          <header>
            <hgroup>
              <h1>To do:</h1>
            </hgroup>
          </header>
          <section>
          </section>
        </section>
        <section id="doing" class="state">
          <header>
            <hgroup>
              <h1>Doing:</h1>
            </hgroup>
          </header>
          <section>
          </section>
        </section>
        <section id="done" class="state">
          <header>
            <hgroup>
              <h1>Done:</h1>
            </hgroup>
          </header>
          <section>
          </section>
        </section>
      </div>
      <div class="group horizontal">
        <section id="unscheduled" class="state">
          <header>
            <hgroup>
              <h1>Unscheduled:</h1>
            </hgroup>
          </header>
          <section>
          </section>
        </section>
      </div>
    </div>
  </section>
<script>
  'use strict';
  var editpad = document.getElementById('editpad');
  function parse_and_draw() {
    parse_source(editpad.value);
    draw_tasks(tasks);
  }

  var timeToSave = 0;
  editpad.addEventListener('input', function (evt) {
    editpad.classList.add('modified');
    clearTimeout(timeToSave);
    timeToSave = setTimeout(function save() {
      localStorage['text'] = editpad.value;
      editpad.classList.remove('modified');
    }, 1000);
  });

  editpad.addEventListener('input', parse_and_draw);

  /**
   * From http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript
   * Converts an RGB color value to HSL. Conversion formula
   * adapted from http://en.wikipedia.org/wiki/HSL_color_space.
   * Assumes r, g, and b are contained in the set [0, 255] and
   * returns h, s, and l in the set [0, 1].
   *
   * @param   Number  r       The red color value
   * @param   Number  g       The green color value
   * @param   Number  b       The blue color value
   * @return  Array           The HSL representation
   */
  function rgbToHsl(r, g, b){
      r /= 255, g /= 255, b /= 255;
      var max = Math.max(r, g, b), min = Math.min(r, g, b);
      var h, s, l = (max + min) / 2;

      if(max === min){
          h = s = 0; // achromatic
      }
      else {
          var d = max - min;
          s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
          switch(max){
              case r: h = (g - b) / d + (g < b ? 6 : 0); break;
              case g: h = (b - r) / d + 2; break;
              case b: h = (r - g) / d + 4; break;
          }
          h /= 6;
      }

      return [h, s, l];
  }

  var DEFAULT_TASK_COLOR = '#FFE073';

  // From http://24ways.org/2010/calculating-color-contrast
  function get_contrast_YIQ(hexcolor){
    var r = parseInt(hexcolor.substr(1,2),16);
    var g = parseInt(hexcolor.substr(3,2),16);
    var b = parseInt(hexcolor.substr(5,2),16);
    var yiq = ((r*299)+(g*587)+(b*114))/1000;
    return (yiq >= 128) ? '#000000' : '#FFFFFF';
  }

  function hexToRgb(hexcolor) {
    // malformed color
    if (hexcolor[0] !== '#'
        || (hexcolor.length !== 4 && hexcolor.length !== 7))

      hexcolor = DEFAULT_TASK_COLOR;


    // normalize color
    if (hexcolor.length === '4')
      hexcolor = '#'
                 + hexcolor[1] + hexcolor[1]
                 + hexcolor[2] + hexcolor[2]
                 + hexcolor[3] + hexcolor[3];

    // calculate RGB values
    return [
      parseInt(hexcolor.substr(1,2), 16),
      parseInt(hexcolor.substr(3,2), 16),
      parseInt(hexcolor.substr(5,2), 16)
    ];
  }

  function get_id(string) {
    string = string.trim();
    string = string.toLowerCase();
    string = string.replace(/[\s-+]/g, '_');
    string = string.replace(/\W/g, '');
    return string;
  }

  function wrap_hsl(components) {
    return 'hsl('+Math.round(components[0]*360)+','
                 +Math.round(components[1]*100)+'%,'
                 +Math.round(components[2]*100)+'%)';
  }

  function get_color_scheme(hexcolor) {
    var base, text, border;
    base = rgbToHsl.apply(null, hexToRgb(hexcolor));
    text = get_contrast_YIQ(hexcolor);
    border = [base[0], base[1], base[2] * 0.75];
    return {
      'background-color': wrap_hsl(base),
      'color': text,
      'border-color': wrap_hsl(border)
    };
  };

  function new_task_item(task) {
    var task_text = 'Task';
    var category_text = 'Category';
    var completion_text = 'Completion';
    var due_text = 'Due date';

    var html = '<hgroup><h1>'+task.title+'</h1></hgroup>';
    if (task.description)
      html += '<p>'+task.description+'</p>';
    html += '<aside class="details"><dl>';

    html += '<dt>'+task_text+'</dt>';
    html += '<dd>'+task.id+'</dd>';

    if (task.category) {
      html += '<dt>'+category_text+'</dt>';
      html += '<dd>'+categories[task.category].name+'</dd>';
    }

    if (task.completion) {
      var max = parseInt(task.completion.total);
      var value = parseInt(task.completion.completed) || '0';
      html += '<dt>'+completion_text+'</dt>';
      html += '<dd><progress value="'+value+'" max="'+max+'"></progress></dd>';
    }

    if (task.completion && task.completion.due) {
      var max = parseInt(task.completion.total);
      var value = parseInt(task.completion.completed) || '0';
      html += '<dt>'+due_text+'</dt>';
      html += '<dd>'+task.completion.due+'</dd>';
    }

    html += '</dl>';

    var article = document.createElement('article');
    article.innerHTML = html;
    article.classList.add('task');
    article.setAttribute('contenteditable', 'false');
    if (task.category) {
      var color = categories[task.category].color;
      var color_scheme = get_color_scheme(color);
      article.style.backgroundColor = color_scheme['background-color'];
      article.style.borderColor = color_scheme['border-color'];
      article.style.color = color_scheme['color'];
    }
    return article;
  }

  function draw_tasks(tasks) {
    // Clear states
    var tasks_containers = document.querySelectorAll('.state section');
    [].forEach.call(tasks_containers, function (container) {
      container.innerHTML = '';
    });

    // Draw each task where it belongs to
    for (var task_id in tasks) {
      var task = tasks[task_id];
      var state_id = task.state;
      if (state_id) {
        var container = document.querySelector('#'+state_id+' section');
        container.appendChild(new_task_item(task));
      }
    }
  }

  var tasks, states, categories;
  function parse_source(source) {
    tasks = {}, states = {}, categories = {};

    var task, looking_for_description = true;
    var state_header = /^(.+?):$/i;
    var category_header = /^(.+?)(?:\s+\(\s*(.*?)\s*\)\s*)?:$/i;
    var task_header = /^task\s+(.+?)(?::\s*(.*))?$/i;
    var task_completion = /^>>\s*(.*?)(?:\/(.*?))?\s*(?:\((.*?)\))?$/;
    var separator = /^-{2,}$/;
    var mode = 'state';

    var lines = source.split('\n');

    var current_task, current_state, current_category;
    var parsing_task = false, starting_description = false;
    for (var i=0, len=lines.length; i<len; i++) {

      var line = lines[i];
      var trimmed = line.trim();

      if (!trimmed) {
        parsing_task = false;
        continue;
      }

      // Separator found, now looking for classification
      var separator_found = separator.exec(trimmed);
      if (separator_found && mode === 'state') {
        parsing_task = false;
        current_state = undefined;
        mode = 'classification';
        continue;
      }

      // Looking for a task definition
      var task_found = task_header.exec(trimmed);
      if (task_found) {
        parsing_task = true;
        starting_description = true;
        current_task = get_id(task_found[1]);

        // not already defined, create new
        if (!tasks[current_task]) {
          tasks[current_task] = {
            id: current_task,
            title: task_found[2] || task_found[1],
            category: current_category,
            state: current_state
          };
        }

        // already defined, expand it
        else {
          if (task_found[2])
            tasks[current_task].title = task_found[2];
          if (current_category)
            tasks[current_task].category = current_category;
          if (current_state)
            tasks[current_task].state = current_state;
        }

        continue;
      }

      // Looking for task completion
      if (parsing_task) {
        var completion_found = task_completion.exec(trimmed);
        if (completion_found) {
          parsing_task = false;
          tasks[current_task].completion = {
            completed: completion_found[2] ? completion_found[1] : undefined,
            total: completion_found[2] || completion_found[1],
            due: completion_found[3] || undefined
          };
          continue;
        }
      }

      var rtrimmed = line.replace(/\s*$/, '');

      // The State is the set of tasks distributed among the different states
      if (mode === 'state') {
        // New state found, tasks found since now are in this state
        var state_found = state_header.exec(rtrimmed);
        if (state_found && !parsing_task) {
          current_state = get_id(state_found[1]);
          states[current_state] = {
            id: current_state,
            name: state_found[1]
          };
          continue;
        }
      }

      // The Classification is a space where to distribute tasks among
      // categories
      else if (mode === 'classification') {
        // New category found, tasks found since now belong to this category
        var category_found = category_header.exec(rtrimmed);
        if (category_found && !parsing_task) {
          current_category = get_id(category_found[1]);
          categories[current_category] = {
            id: current_category,
            name: category_found[1],
            color: category_found[2] || DEFAULT_TASK_COLOR
          };
          continue;
        }
      }

      // Any remaining patter is ignored or added as description if we are
      // parsing a task
      if (parsing_task) {

        // if no description or recently started recognizing description
        if (!tasks[current_task].description || starting_description) {
          tasks[current_task].description = trimmed;
          starting_description = false;
        }

        else
          tasks[current_task].description += ' '+trimmed;

        continue;
      }
    }

    console.dir(tasks);
  }

  var localText = localStorage['text'];
  if (localText)
    editpad.value = localText;

  parse_and_draw();
</script>
</body>
</html>


